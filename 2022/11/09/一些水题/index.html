<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>一些水题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1 MyBatis1.1 mybatis 中 #{}和 ${}的区别是什么？#{}是占位符，${}是拼接符 ，#{}生成后的sql语句是？占位，而${}直接是字符串拼接 1.2 mybatis 逻辑分页和物理分页的区别是什么？物理分页：sql语句指定，查询哪一页的数据，只会取那一页的那几条数据出来，速度上并不一定快于逻辑分页。逻辑分页：第一次将所有的数据全部取出来放入内存中，需要使用时，取对应页的">
<meta property="og:type" content="article">
<meta property="og:title" content="一些水题">
<meta property="og:url" content="http://example.com/2022/11/09/%E4%B8%80%E4%BA%9B%E6%B0%B4%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 MyBatis1.1 mybatis 中 #{}和 ${}的区别是什么？#{}是占位符，${}是拼接符 ，#{}生成后的sql语句是？占位，而${}直接是字符串拼接 1.2 mybatis 逻辑分页和物理分页的区别是什么？物理分页：sql语句指定，查询哪一页的数据，只会取那一页的那几条数据出来，速度上并不一定快于逻辑分页。逻辑分页：第一次将所有的数据全部取出来放入内存中，需要使用时，取对应页的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/i1.png">
<meta property="article:published_time" content="2022-11-09T02:11:42.000Z">
<meta property="article:modified_time" content="2022-11-12T04:04:08.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/i1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-一些水题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/09/%E4%B8%80%E4%BA%9B%E6%B0%B4%E9%A2%98/" class="article-date">
  <time datetime="2022-11-09T02:11:42.000Z" itemprop="datePublished">2022-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      一些水题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-MyBatis"><a href="#1-MyBatis" class="headerlink" title="1 MyBatis"></a>1 MyBatis</h2><h3 id="1-1-mybatis-中-和-的区别是什么？"><a href="#1-1-mybatis-中-和-的区别是什么？" class="headerlink" title="1.1 mybatis 中 #{}和 ${}的区别是什么？"></a>1.1 mybatis 中 #{}和 ${}的区别是什么？</h3><p>#{}是占位符，${}是拼接符 ，#{}生成后的sql语句是？占位，而${}直接是字符串拼接</p>
<h3 id="1-2-mybatis-逻辑分页和物理分页的区别是什么？"><a href="#1-2-mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="1.2 mybatis 逻辑分页和物理分页的区别是什么？"></a>1.2 mybatis 逻辑分页和物理分页的区别是什么？</h3><p>物理分页：sql语句指定，查询哪一页的数据，只会取那一页的那几条数据出来，速度上并不一定快于逻辑分页。<br>逻辑分页：第一次将所有的数据全部取出来放入内存中，需要使用时，取对应页的片段。速度上也并不一定快于物理分页。 </p>
<p>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点</p>
<p>pagehelper分页的实现原理就是通过拦截器拦截待执行的sql，然后再重写sql，添加物理分页语句和物理分页参数 </p>
<h3 id="1-3-mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#1-3-mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="1.3 mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>1.3 mybatis 是否支持延迟加载？延迟加载的原理是什么？</h3><p>MyBatis是支持延迟加载的。<br>其原理是通过cglib创建目标对象的代理对象，调用目标方法时，先进入拦截器方法，然后再进行数据库查询。<br>比如说查询出一个a对象，a中有需要延时加载的b对象，b对象此时为null。通过cglib创建了a的代理对象，在调用a.getB().getName()时拦截器invoke()方法发现a.getB()是null，就会单独发送事先保存好的查询关联B对象的sql，把B查询出来。然后调用a.setB(b)，这样a对象的b属性就会有值了，接着完成a.getB().getName()方法的调用，这就是延迟加载的基本原理</p>
<h3 id="1-4-说一下-mybatis-的一级缓存和二级缓存？"><a href="#1-4-说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="1.4 说一下 mybatis 的一级缓存和二级缓存？"></a>1.4 说一下 mybatis 的一级缓存和二级缓存？</h3><p>一级缓存是Sqlsession级别的缓存，也就是同一个Sqlsession内执行两次或多次相同结果的查询语句，只会再第一次发送sql语句查询<br>二级缓存默认是不开启的，是Mapper级别的缓存，是多个Sqlsession之间可以共享数据</p>
<h3 id="1-5-mybatis-和-hibernate-的区别有哪些？"><a href="#1-5-mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="1.5 mybatis 和 hibernate 的区别有哪些？"></a>1.5 mybatis 和 hibernate 的区别有哪些？</h3><p>mybatis和hibernate不同，它不完全是一个ORM框架，因为Mybatis需要程序员自己编写sql<br>mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，但是灵活的前提是mybatis无法做到数据库无关性<br>hibernate对象/关系映射能力强，数据库无关性好 </p>
<h3 id="1-6-mybatis-有哪些执行器（Executor）？"><a href="#1-6-mybatis-有哪些执行器（Executor）？" class="headerlink" title="1.6 mybatis 有哪些执行器（Executor）？"></a>1.6 mybatis 有哪些执行器（Executor）？</h3><p>SimpleExecutor：简单执行器，每次执行一个update或select，就开启一个statment对象，用完就关闭<br>ReuseExecutor：重用执行器，执行update或select，以sql作为key查找statment对象，存在就是用，不存在就创建，用完后不关闭<br>BatchExecutor：批处理执行器，执行update，将所有sql都添加到批处理中，等待统一执行<br>MyBatis中默认使用的是SimpleExecutor执行器，如果需要更改，可选择局部更改或全局更改</p>
<img src="/images/i1.png">

<h2 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2 Spring"></a>2 Spring</h2><h3 id="2-1-什么是Spring？"><a href="#2-1-什么是Spring？" class="headerlink" title="2.1 什么是Spring？"></a>2.1 什么是Spring？</h3><p>Spring 是一个分层的 JavaSE/EE Full-Stack（一站式） 轻量级开源框架，可以说他是一个整合型框架，可以整合市场上大多数的框架，Spring的核心的IOC(控制反转)和AOP(切面编程)，同时他也能很方便的管理事务</p>
<h3 id="2-2-为什么要使用-spring？"><a href="#2-2-为什么要使用-spring？" class="headerlink" title="2.2 为什么要使用 spring？"></a>2.2 为什么要使用 spring？</h3><p>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）<br>2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）<br>3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）<br>5.方便集成各种优秀的框架<br>4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序<br>6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低） </p>
<h3 id="2-3-解释一下什么是-aop？"><a href="#2-3-解释一下什么是-aop？" class="headerlink" title="2.3 解释一下什么是 aop？"></a>2.3 解释一下什么是 aop？</h3><p>在业务系统中，总有一些不得不处理的事情，我们将这些重复性的代码抽取出来，放在专门的类中， 在通过spring的AOP的核心对代码段进行增强处理。 在不改变原代码的基础上进行功能增强。有五种增强方式，前置增强，后置增强，环绕增强，引介(返回)增强，异常增强。 </p>
<h3 id="2-4-解释一下什么是-ioc？"><a href="#2-4-解释一下什么是-ioc？" class="headerlink" title="2.4 解释一下什么是 ioc？"></a>2.4 解释一下什么是 ioc？</h3><p>ioc（inverse of control ）控制反转：所谓控制反转就是把对象（bean）和维护对象（bean）之间的关系 的权利转移到Sqring容器中去了，而程序本身不在维护。</p>
<p>di（dependency injection）依赖注入：实际上DI和IOC是同一个概念，因为在ApplicationContext.xml配置文件中bean和bean之间通过ref来维护的时候是相互依赖的，所以又叫做依赖注入。</p>
<h3 id="2-5-Spring创建bean的注解有几种？"><a href="#2-5-Spring创建bean的注解有几种？" class="headerlink" title="2.5 Spring创建bean的注解有几种？"></a>2.5 Spring创建bean的注解有几种？</h3><p>主要有四种注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：<br>@Component：可以用于注册所有bean<br>@Repository：主要用于注册dao层的bean<br>@Controller：主要用于注册控 制层的bean<br>@Service：主要用于注册服务层的bean </p>
<h3 id="2-6-spring-常用的注入方式有哪些？"><a href="#2-6-spring-常用的注入方式有哪些？" class="headerlink" title="2.6 spring 常用的注入方式有哪些？"></a>2.6 spring 常用的注入方式有哪些？</h3><p>构造方法注入，sette注入，基于注解的注入</p>
<h3 id="2-7-spring-中的-bean-是线程安全的吗？"><a href="#2-7-spring-中的-bean-是线程安全的吗？" class="headerlink" title="2.7 spring 中的 bean 是线程安全的吗？"></a>2.7 spring 中的 bean 是线程安全的吗？</h3><p>容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>
<h3 id="2-8-spring-支持几种-bean-的作用域？"><a href="#2-8-spring-支持几种-bean-的作用域？" class="headerlink" title="2.8 spring 支持几种 bean 的作用域？"></a>2.8 spring 支持几种 bean 的作用域？</h3><p>singleton：单例模式，在整个Spring IoC容器中，使用 singleton 定义的 bean 只有一个实例<br>prototype：原型模式，每次通过容器的getbean方法获取 prototype 定义的 bean 时，都产生一个新的 bean 实例</p>
<h3 id="2-9-spring-自动装配-bean-有哪些方式？"><a href="#2-9-spring-自动装配-bean-有哪些方式？" class="headerlink" title="2.9 spring 自动装配 bean 有哪些方式？"></a>2.9 spring 自动装配 bean 有哪些方式？</h3><p>（1）在XML中进行显式配置<br>（2）在java中进行显式配置<br>（3）隐式的bean发现和自动装配（一般推荐使用自动装配bean的方式） </p>
<h3 id="2-10-spring-事务实现方式有哪些？"><a href="#2-10-spring-事务实现方式有哪些？" class="headerlink" title="2.10 spring 事务实现方式有哪些？"></a>2.10 spring 事务实现方式有哪些？</h3><p>（1）编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、 commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。<br>（2）基于 TransactionProxyFactoryBean的声明式事务管理<br>（3）基于 @Transactional 的声明式事务管理<br>（4）基于Aspectj AOP配置事务 </p>
<h3 id="2-11-说一下-spring-的事务隔离？"><a href="#2-11-说一下-spring-的事务隔离？" class="headerlink" title="2.11 说一下 spring 的事务隔离？"></a>2.11 说一下 spring 的事务隔离？</h3><p>READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。 </p>
<p>READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，<br>可避免脏读，仍会出现不可重复读和幻读问题。 </p>
<p>REPEATABLE READ（可重复读）：确保事务可以多次从一个字<br>段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。 </p>
<p>SERIALIZABLE（序列化）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止<br>其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。 Spring隔离级别</p>
<h2 id="3-SpringMVC"><a href="#3-SpringMVC" class="headerlink" title="3 SpringMVC"></a>3 SpringMVC</h2><h3 id="3-1-SpringMVC和Spring的关系是什么？"><a href="#3-1-SpringMVC和Spring的关系是什么？" class="headerlink" title="3.1 SpringMVC和Spring的关系是什么？"></a>3.1 SpringMVC和Spring的关系是什么？</h3><p>因为springMVC的运行需要依赖spring，可以将springMVC看做是spring的一个组件.</p>
<h3 id="3-2-说一下-Spring-MVC-运行流程？"><a href="#3-2-说一下-Spring-MVC-运行流程？" class="headerlink" title="3.2 说一下 Spring MVC 运行流程？"></a>3.2 说一下 Spring MVC 运行流程？</h3><p>用户发送请求到前端控制器DispatcherServlet，之后调用HanderMapping处理器找到具体的处理器返回，再调用 HanderAdapter处理适配器，再调用具体的Controller，执行完后返回Modeandview，HanderAdapter将结果返回 给DispatcherServlet，再传给ViewResover视图解析器解析后返回View，DispatcherServlet渲染后响应</p>
<h3 id="3-3-spring-mvc-有哪些组件？"><a href="#3-3-spring-mvc-有哪些组件？" class="headerlink" title="3.3 spring mvc 有哪些组件？"></a>3.3 spring mvc 有哪些组件？</h3><p>HanderMapping处理请求，HanderAdapter适配器，ViewResolver视图解析，Contoller处理器，DispatcherServlet</p>
<h3 id="3-4-RequestMapping-的作用是什么？"><a href="#3-4-RequestMapping-的作用是什么？" class="headerlink" title="3.4 @RequestMapping 的作用是什么？"></a>3.4 @RequestMapping 的作用是什么？</h3><p>处理请求地址映射的注解，如果用于类上，表示类中的所有响应请求方法都是以该路径作为父路径</p>
<h3 id="3-5-Autowired-的作用是什么？"><a href="#3-5-Autowired-的作用是什么？" class="headerlink" title="3.5 @Autowired 的作用是什么？"></a>3.5 @Autowired 的作用是什么？</h3><p>对类成员变量、方法和构造函数进行标注，完成自动装配的工作 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/09/%E4%B8%80%E4%BA%9B%E6%B0%B4%E9%A2%98/" data-id="clf0inbj800097wttfhho7ybr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/09/%E5%8D%9A%E5%AE%A2Error/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          博客Error
        
      </div>
    </a>
  
  
    <a href="/2022/10/25/Error/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Error</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/01/log/">log</a>
          </li>
        
          <li>
            <a href="/2023/03/01/flow/">flow</a>
          </li>
        
          <li>
            <a href="/2022/11/09/%E5%8D%9A%E5%AE%A2Error/">博客Error</a>
          </li>
        
          <li>
            <a href="/2022/11/09/%E4%B8%80%E4%BA%9B%E6%B0%B4%E9%A2%98/">一些水题</a>
          </li>
        
          <li>
            <a href="/2022/10/25/Error/">Error</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>